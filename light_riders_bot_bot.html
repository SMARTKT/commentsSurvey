<!DOCTYPE html>
<html>
  <head>
    <title>What a comment!</title>
    <link href="./styles/prism.css" rel="stylesheet" />
    <link href="./styles/form.css" rel="stylesheet" />
  </head>
    <style>
	.btnc {

	    background-color: #1e7ef4;
	    border: none;
	    color: white;
	    padding: 8px 12px;
	    text-align: center;
	    font-size: 12px;
	    font-weight: bold;
	    margin: 4px 2px;
	    opacity: 0.6;
	    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);

	    transition: 0.4s;
	  }

	  .btnc:hover {opacity: 1}
	  </style>
  <body>

  	<div class="form-popup" id="myForm">
	  <form action="/action_page.php" class="form-container" onsubmit="return postToGoogle();">

      <label for="emailField"><b>Email id</b></label>
      <input type="email" id="emailField" name="emailField" required><br>

      <label for="nameField"><b>Full name</b></label>
      <input type="text" name="nameField" id="nameField" required><br>

      <label for="designationField"><b>Designation</b></label>
      <input type="text" name="designationField" id="designationField" placeholder="Student / Employee" required><br>

      <label for="affiliationField"><b>Affiliation</b></label>
      <input type="text" name="affiliationField" id="affiliationField" placeholder="University / Company" required><br>

	    <label for="commentUsefulness"><b>This comment is </b></label>
	    <input id="commentUseful" type="radio" name="commentUsefulness" value="U" required> Useful
		<input id="commentNotUseful" type="radio" name="commentUsefulness" value="NU" required> Useless
    <input id="commentPartialUseful" type="radio" name="commentUsefulness" value="PU" required> Partially Useful<br>

	    <label for="commentView"></label>
	    <input id="commentView" type="text" placeholder="Why do you think so?" name="commentView" required>

	    <label for="commentAlternate"></label>
	    <textarea id="commentAlternate" type="text" placeholder="If you would have written a comment for that portion of the code, what would you have written? (optional)" name="commentAlternate" style="height:100px;"></textarea> 

	    <button type="submit" class="btn">Submit</button>
	    <button id="closeFormButton" type="reset" class="btn cancel" onclick="closeForm()">Close</button>
	  </form>
	</div>


  	<script src="./javascript/prism.js"></script>
  	<pre>
  		<table>
  			<!--start-->
<div hidden id="commentCodeID">light_riders_bot_bot</div><tr>
<td><pre><code class="language-py"># Use the game by - pip install git+https://github.com/wonderworks-software/PyFlow.git@master </code></pre></td>
<td><button class="btnc" type="button" id="comment1" onclick="openForm(this.id)">Comment 1</button></td>
</tr>
<tr>
<td><pre><code class="language-py">class Bot: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def __init__(self): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        self.game = None </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        self.last_move = None </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def setup(self, game): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        self.game = game </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    returns the next possible position of the my bot based on the given direction </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def next_pos(self, direction, pos=None): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        if direction == "up": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            if pos is None: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                return self.game.my_player().row - 1, self.game.my_player().col </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                row, col = pos </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                return row - 1, col </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        elif direction == "down": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            if pos is None: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                return self.game.my_player().row + 1, self.game.my_player().col </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                row, col = pos </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                return row + 1, col </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        elif direction == "left": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            if pos is None: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                return self.game.my_player().row, self.game.my_player().col - 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                row, col = pos </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                return row, col - 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        elif direction == "right": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            if pos is None: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                return self.game.my_player().row, self.game.my_player().col + 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                row, col = pos </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                return row, col + 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    applies the flood fill algorithm for the given position </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def flood_use(self, position): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        visited = [] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        return self.flood_fill(position, visited) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    flood fill algorithm implementation. </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    Returns the count of legal boxes on our field for the given position </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def flood_fill(self, position, visited): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        row, col = position </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        # if we are out of bounds </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        # or have already visited the current position </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        # or can't visit this box </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        if row &lt; 0 or col &lt; 0 or row > self.game.field_width - 1 or \ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        col > self.game.field_height - 1 or position in visited \ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                or not self.game.field.is_legal_tuple(position, self.game.my_botid): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            return 0  # count is 0 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        visited.append(position)  # mark current position as visited </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        # get position count recursively from the current box till the end </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        # or an illegal box </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        return 1 + self.flood_fill((row - 1, col), visited) \ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">               + self.flood_fill((row + 1, col), visited) \ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">               + self.flood_fill((row, col - 1), visited) \ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">               + self.flood_fill((row, col + 1), visited) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def do_turn(self): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        my_row = self.game.my_player().row </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        my_col = self.game.my_player().col </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        legal = self.game.field.legal_moves(self.game.my_botid, self.game.players) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        print(legal) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        # with open('log.txt', 'a') as file: </code></pre></td>
<td><button class="btnc" type="button" id="comment2" onclick="openForm(this.id)">Comment 2</button></td>
</tr>
<tr>
<td><pre><code class="language-py">        #     file.write("Round: " + str(self.game.round) + " Begin!\n" + "length of legal_dirs: " + str(len(legal)) + "\n") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        if len(legal) == 0: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            desired_direction = "pass" </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            # remove useless tuples from legal var </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            legal_dirs = []  # legal directions (legal moves w/o the tuples) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            for _, direction in legal: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                legal_dirs.append(direction) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            # if on first round </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            # just head to the nearest wall </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            if self.game.round == 0: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # calculate distances from each wall </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                dist_to_walls = {} </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                dist_to_walls["up"] = my_row </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                dist_to_walls["down"] = self.game.field_height - my_col </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                dist_to_walls["left"] = my_col </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                dist_to_walls["right"] = self.game.field_width - my_row </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # find min distance </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                desired_direction = min(dist_to_walls, key=dist_to_walls.get) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            # if not on first round </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # TODO Maybe add dead end check? (only needed when next move is "pass") </code></pre></td>
<td><button class="btnc" type="button" id="comment3" onclick="openForm(this.id)">Comment 3</button></td>
</tr>
<tr>
<td><pre><code class="language-py">                # TODO Maybe can add it before issue_order_pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # Remove unallowed moves (it seems that is_legal wasn't good enough) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                if self.last_move == "up": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        # legal_dirs.remove("up") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        legal_dirs.remove("down") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    except ValueError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                elif self.last_move == "down": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        # legal_dirs.remove("down") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        legal_dirs.remove("up") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    except ValueError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                elif self.last_move == "left": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        # legal_dirs.remove("left") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        legal_dirs.remove("right") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    except ValueError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                elif self.last_move == "right": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        # legal_dirs.remove("right") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        legal_dirs.remove("left") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    except ValueError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # Check if any immediate neighbor square is illegal move and remove it </code></pre></td>
<td><button class="btnc" type="button" id="comment4" onclick="openForm(this.id)">Comment 4 (LAST)</button></td>
</tr>
<tr>
<td><pre><code class="language-py">                my_id = self.game.my_botid </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                if not self.game.field.is_legal_tuple((my_row - 1, my_col), my_id): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        legal_dirs.remove("up") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    except ValueError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                if not self.game.field.is_legal_tuple((my_row + 1, my_col), my_id): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        legal_dirs.remove("down") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    except ValueError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                if not self.game.field.is_legal_tuple((my_row, my_col - 1), my_id): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        legal_dirs.remove("left") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    except ValueError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                if not self.game.field.is_legal_tuple((my_row, my_col + 1), my_id): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        legal_dirs.remove("right") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    except ValueError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        pass </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                if len(legal_dirs) == 1: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    desired_direction = legal_dirs[0] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # Flood fill count in 2 directions to find max space and make the move </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # that leads there </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                elif len(legal_dirs) == 2: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    first_move = legal_dirs[0] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    second_move = legal_dirs[1] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    first_move_next = self.next_pos(first_move) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    second_move_next = self.next_pos(second_move) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    next_moves_counts = {} </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    next_moves_counts[first_move] = self.flood_use(first_move_next) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    next_moves_counts[second_move] = self.flood_use(second_move_next) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    if next_moves_counts[first_move] == next_moves_counts[second_move]: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        next_moves_dists = {} </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        next_moves_dists[first_move] = self.dist_to_obstacle(first_move) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        next_moves_dists[second_move] = self.dist_to_obstacle(second_move) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        desired_direction = max(next_moves_dists, key=next_moves_dists.get) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        desired_direction = max(next_moves_counts, key=next_moves_counts.get) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # Flood fill count in 3 directions to find max space and make the move </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                # that leads there </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                elif len(legal_dirs) == 3: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    first_move = legal_dirs[0] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    second_move = legal_dirs[1] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    third_move = legal_dirs[2] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    first_move_next = self.next_pos(first_move) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    second_move_next = self.next_pos(second_move) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    third_move_next = self.next_pos(third_move) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    next_moves_counts = {} </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    next_moves_counts[first_move] = self.flood_use(first_move_next) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    next_moves_counts[second_move] = self.flood_use(second_move_next) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    next_moves_counts[third_move] = self.flood_use(third_move_next) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    if next_moves_counts[first_move] != next_moves_counts[second_move] or \ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                                    next_moves_counts[first_move] != next_moves_counts[third_move] or \ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                                    next_moves_counts[second_move] != next_moves_counts[third_move]: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        desired_direction = max(next_moves_counts, key=next_moves_counts.get) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        desired_direction = self.voronoi(legal_dirs) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                else:  # this probably never comes up - not sure </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    desired_direction = "pass" </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        # with open('log.txt', 'a') as file: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        #     file.write("End: length of legal_dirs: " + str(len(legal_dirs)) + "\n") </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        if desired_direction == "pass": </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            self.last_move = "pass" </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            self.game.issue_order_pass() </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        else: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            self.last_move = desired_direction </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            self.game.issue_order(desired_direction) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    Voronoi algorithm implementation </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    Returns the max number of voronoiValues (A.K.A. the best suitable move against an opponent) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    # possibleMoves == legalDirs </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def voronoi(self, possibleMoves): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        voronoi_values = {} </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        # compare all possible moves </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        for move in possibleMoves: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            map1 = self.game.field.cell </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            next_x, next_y = self.next_pos(move) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            row = self.game.my_player().row </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            col = self.game.my_player().col </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            # create updated maps </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            map1[row][col] = [3] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            try: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                map1[next_x][next_y] = [self.game.my_botid] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            except IndexError: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                with open('log.txt', 'a') as file: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    file.write('Index Error') </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            map2 = map1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            my_spaces = 0 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            enemy_spaces = 0 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            for x in range(0, self.game.field_height): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                for y in range(0, self.game.field_width): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    # with open('log.txt', 'a') as file: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    #     file.write('x, y: ' + str(x) + ' , ' + str(y) + '\n') </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    self.lee_map((row, col), (x, y), map1, 0) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    self.lee_map((row, col), (x, y), map2, 0) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    position = x, y </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                    if self.game.field.is_legal(x, y, self.game.my_botid): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        my_dist = map1[x][y] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        enemy_dist = map2[x][y] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        # compare distances between two players </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        if my_dist &lt; enemy_dist: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                            my_spaces += 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                        elif my_dist > enemy_dist: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">                            enemy_spaces += 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            voronoi_values[move] = my_spaces - enemy_spaces </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        return max(voronoi_values, key=voronoi_values.get) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    helper function that computes the distance in every map </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def lee_map(self, start, target, map, dist): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        x, y = start </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        with open('log.txt', 'a') as file: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            file.write(str(map[x][y][0]) + '\n') </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        if start == target: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            map[x][y] = [dist] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            return </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        if map[x][y][0] == 2: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            # with open('log.txt', 'a') as file: </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            #     file.write(str(map[x][y][0]) + '\n') </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            map[x][y] = [dist] </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            dist += 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            self.lee_map((x - 1, y), target, map, dist) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            dist += 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            self.lee_map((x + 1, y), target, map, dist) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            dist += 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            self.lee_map((x, y - 1), target, map, dist) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            dist += 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            self.lee_map((x, y + 1), target, map, dist) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    function that computes the distance of a player from an obstacle </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    """ </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py"> </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">    def dist_to_obstacle(self, direction): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        dist = 0 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        next = self.next_pos(direction) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        while self.game.field.is_legal_tuple(next, self.game.my_botid): </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            dist += 1 </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            temp = next </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">            next = self.next_pos(direction, pos=temp) </code></pre></td>
</tr>
<tr>
<td><pre><code class="language-py">        return dist </code></pre></td>
</tr>
  <!-- end -->
  		</table>
  		
  		<code class="language-py">
  		</code>
  	</pre>
  </body>
</html>
<script async src="./javascript/index.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>